package ui;

import core.*;
import core.animations.Animation;
import worldmap.MapCharacter;
import worldmap.MapConfiguration;
import worldmap.MapEntity;
import worldmap.MapModelState;

import java.awt.Graphics;
import java.awt.Image;
import javax.swing.ImageIcon;

import control.DS_Action;
import control.DS_Actionable;
import control.DebugLogger;
import control.KeyBinding;

/**
 * Stores information about the state of the game's map view. Each map should have its
 * own instance of this class.
 * 
 * @author jhshi
 *
 */
public class MapViewState implements DS_Actionable {
	
	public static KeyBinding<VisualAction> VISUAL_BINDINGS;
	
	/**
	 * Converts the number of scroll units generated by a MouseWheelEvent
	 * to the change in MapEntity.mapScale.
	 */
	public final static double SCROLL_SCALE = 0.01;
	
	/**
	 * The farthest in that you can zoom.
	 * @see MapEntity.mapScale
	 */
	public final double MAX_SCALE;
	/**
	 * The farthest out that you can zoom.
	 * @see MapEntity.mapScale
	 */
	public final double MIN_SCALE;
	
	public static DebugLogger log = new DebugLogger("MapViewState");
	
	public MapViewState() {
		this(0.5);
	}
	
	public MapViewState(double scale) {
		this(scale, 0.2, 1.5);
	}
	
	public MapViewState(double scale, double minScale, double maxScale) {
		this.mapScale = scale;
		this.MIN_SCALE = minScale;
		this.MAX_SCALE = maxScale;
		
		selector = new Selector();
		selector.hide();
	}
	
	public void paintElements(MapPanel caller, Graphics g) {
		selector.paint(caller, g);
	}

	/**
	 * Gets the drawing scale of the map in view.
	 */
	private double mapScale;
	
	/**
	 * Gets the displacement of the center of the screen from the original center.
	 */
	private IntVector2D disp = new IntVector2D(0, 0);
	
	/**
	 * The coordinates of the tile currently selected by the user.
	 */
	private IntVector2D selected;
	private IntVector2D examined;
	private MapEntity examinedFriendly;
	
	private Selector selector;
	
	private boolean selecting = false;
	private boolean examining = false;
	
	public boolean isSelecting() {
		return selecting;
	}
	
	public void setSelecting(boolean s) {
		this.selecting = s;
	}
	
	public void deselect(MapPanel caller) {
		selecting = false;
		examining = false;
		selector.pause();
		selector.hide();
		caller.repaint();
	}
	
	public void select(MapPanel caller) {
		selecting = true;
		selector.restart();
		selector.unpause();
		selector.unhide();
		changeSelectedToCenter(caller);
		selector.setPos(selected);
		caller.repaint();
	}
	
	public IntVector2D getSelected() {
		return selected;
	}
	
	public boolean isExamining() {
		return selecting && examining;
	}
	
	public IntVector2D getExamined() {
		return examined;
	}
	
	public void examine(MapPanel caller) {
		examining = true;
		examined = selected.clone();
		MapConfiguration config = caller.getMapConfig();
		MapCharacter unit = config.getUnitAt(examined);
		if(unit == null)
			return;
		if(unit.isFriendly() && !unit.hasMoved()) {
			examinedFriendly = unit;
			return;
		}
		examinedFriendly = null;
		if(unit.isFriendly())
			examined = null;
		else if(unit.isEnemy()) {
			if(config.getShownEnemies().containsKey(examined))
				config.getShownEnemies().remove(examined);
			else
				config.getShownEnemies().put(examined, config.findAttackableTo(examined));
			config.clearNonRedEnemySquares();
		}
	}
	
	public void unexamine(MapPanel caller) {
		examining = false;
		examined = null;
		examinedFriendly = null;
	}
	
	public boolean isMoving() {
		return examining && examined != null && examinedFriendly != null;
	}
	
	/**
	 * Returns whether a given tile is currently visible on screen.
	 * 
	 * @param pos
	 * @return
	 */
	private boolean isTileOnScreen(MapPanel caller, IntVector2D pos) {
		IntVector2D ttc = tileToCanvas(pos);
		return ttc.getX() > 0
				&& ttc.getX() + getScaledImgSize() < caller.getWidth()
				&& ttc.getY() > 0
				&& ttc.getY() + getScaledImgSize() < caller.getHeight();
	}
	
	/**
	 * Sets selected, to be used only on the enemy turn.
	 * @param caller
	 * @param pos
	 */
	public void setSelected(MapPanel caller, IntVector2D pos) {
		if(caller.getMapConfig().getSideToMove() != Alignment.ENEMY)
			return;
		selected = pos;
		selector.restart();
		return;
	}
	
	/**
	 * Sets examined, to be used only on the enemy turn.
	 * @param caller
	 * @param pos
	 */
	public void setExamined(MapPanel caller, IntVector2D pos) {
		if(caller.getMapConfig().getSideToMove() != Alignment.ENEMY)
			return;
		examined = pos;
		selector.restart();
		return;
	}
	
	public void changeSelected(MapPanel caller, IntVector2D pos) {
		selector.restart();
		if(!selecting)
			return;
		if(!caller.getMapModelState().isTileOnMap(pos))
			return;
		selected = pos;
		if(!isSelecting())
			selecting = true;
		if(isExamining() && !isMoving()
				&& caller.getMapConfig().isUnitAt(pos)
				&& !caller.getMapConfig().getUnitAt(pos).hasMoved()) {
			log.log("Found unit to examine");
			examine(caller);
		}
		if(!isTileOnScreen(caller, pos))
			centerAbout(caller, pos.getX(), pos.getY());
		log.add("Now selecting tile at " + selected);
	}
	
	public void changeSelected(MapPanel caller, int x, int y) {
		changeSelected(caller, new IntVector2D(x, y));
	}
	
	public void changeSelected(MapPanel caller, DS_Action dir) {
		if(selected == null)
			changeSelectedToCenter(caller);
		switch(dir) {
			case DOWN:
				changeSelected(caller, selected.getX(), selected.getY() + 1);
				break;
			case LEFT:
				changeSelected(caller, selected.getX() - 1, selected.getY());
				break;
			case RIGHT:
				changeSelected(caller, selected.getX() + 1, selected.getY());
				break;
			case UP:
				changeSelected(caller, selected.getX(), selected.getY() - 1);
				break;
			default:
				break;
		}
	}
	
	public IntVector2D stateToTile(int x, int y) {
		return new IntVector2D(x / MapEntity.SIZE, y / MapEntity.SIZE);
	}
	
	/**
	 * Transforms a coordinate specifying the location of a tile to the coordinate of the upper left
	 * corner on the canvas. The overlap adjustment is performed automatically.
	 * 
	 * @param pos
	 * @return A new vector representing the location of the upper left corner of the tile on the canvas.
	 */
	public IntVector2D tileToCanvas(IntVector2D pos) {
		return tileToCanvas(pos.getX(), pos.getY());
	}
	
	public DoubleVector2D tileToCanvas(DoubleVector2D pos) {
		return tileToCanvas(pos.getX(), pos.getY());
	}
	
	/**
	 * Transforms a coordinate specifying the location of a tile to the coordinate of the upper left
	 * corner on the canvas. The overlap adjustment is performed automatically.
	 * 
	 * @param x
	 * @param y
	 * @return A new vector representing the location of the upper left corner of the tile on the canvas.
	 */
	public IntVector2D tileToCanvas(int x, int y) {
		return new IntVector2D((int) ((x * MapEntity.getCoordAdjustment() - disp.getX()) * mapScale),
				(int) ((y * MapEntity.getCoordAdjustment() - disp.getY()) * mapScale));
	}
	
	public DoubleVector2D tileToCanvas(double x, double y) {
		return new DoubleVector2D((x * MapEntity.getCoordAdjustment() - disp.getX()) * mapScale,
				(y * MapEntity.getCoordAdjustment() - disp.getY()) * mapScale);
	}
	
	/**
	 * Transforms a coordinate specifying a pixel on the canvas to the tile it encloses.
	 * Works even if the specified coordinate is not within the map. Trust me, it's a feature.
	 * 
	 * @param x
	 * @param y
	 * @return
	 */
	public IntVector2D canvasToTile(int x, int y) {
		return new IntVector2D((x / mapScale + disp.getX()) / MapEntity.getCoordAdjustment(),
							   (y / mapScale + disp.getY()) / MapEntity.getCoordAdjustment());
	}
	
	/**
	 * Transforms a coordinate specifying a pixel on the canvas to the tile it encloses.
	 * Works even if the specified coordinate is not within the map. Trust me, it's a feature.
	 * 
	 * @param pos
	 * @return
	 */
	public IntVector2D canvasToTile(IntVector2D pos) {
		return canvasToTile(pos.getX(), pos.getY());
	}
	
	public void changeSelectedToCenter(MapPanel p) {
		IntVector2D upleft = canvasToTile(0, 0);
		IntVector2D botright = canvasToTile(p.getWidth(), p.getHeight());
		IntVector2D ns = new IntVector2D((upleft.getX() + botright.getX()) / 2,
												  (upleft.getY() + botright.getY()) / 2);
		MapModelState state = p.getMapModelState();
		if(state.isTileOnMap(ns)) {
			selected = ns;
			return;
		}
		// If the tile isn't there, look downwards
		IntVector2D temp = ns.clone();
		while(temp.getY() < state.getConfig().getYTiles()) {
			temp.setY(temp.getY() + 1);
			if(state.isTileOnMap(temp)) {
				selected = temp;
				return;
			}
		}
		// Look upwards
		temp.set(ns);
		while(temp.getY() > 0) {
			temp.setY(temp.getY() - 1);
			if(state.isTileOnMap(temp)) {
				selected = temp;
				return;
			}
		}
		// Look rightwards
		temp.set(ns);
		while(temp.getX() < state.getConfig().getXTiles()) {
			temp.setX(temp.getX() + 1);
			if(state.isTileOnMap(temp)) {
				selected = temp;
				return;
			}
		}
		// Look leftwards
		temp.set(ns);
		while(temp.getX() > 0) {
			temp.setX(temp.getX() - 1);
			if(state.isTileOnMap(temp)) {
				selected = temp;
				return;
			}
		}
	}
	
	public void drawSelector(MapPanel caller, Graphics g) {
		if(!selecting) {
			if(!selector.isPaused())
				selector.pause();
			return;
		}
		selector.unhide();
		selector.paint(caller, g);
	}
	
	public double getMapScale() {
		return mapScale;
	}
	
	public void setMapScale(double mapScale) {
		this.mapScale = mapScale;
	}
	
	public IntVector2D getMapViewDisp() {
		return disp;
	}
	
	public void setMapViewDisp(int x, int y) {
		disp.setX(x);
		disp.setY(y);
	}
	
	public void setMapViewDisp(IntVector2D v) {
		disp.set(v);
	}
	
	public void zoom(MapPanel panel, int disp, int evx, int evy) {
		IntVector2D startV = canvasToState(evx, evy);
		int x = startV.getX();
		int y = startV.getY();
		double scale0 = getMapScale();
		double change = 1 + SCROLL_SCALE * disp;
		double newMapScale = scale0 * change;
		if(newMapScale > MAX_SCALE)
			newMapScale = MAX_SCALE;
		else if(newMapScale < MIN_SCALE)
			newMapScale = MIN_SCALE;
		setMapScale(newMapScale);
		IntVector2D mapDisp = getMapViewDisp();
		setMapViewDisp((int) (x - (x - mapDisp.getX()) * scale0 / newMapScale),
							     (int) (y - (y - mapDisp.getY()) * scale0 / newMapScale));
		fixOutOfBounds(panel);
		panel.repaint();
	}
	
	/**
	 * Centers the screen about a given coordinate, identified as the number of the tile
	 * on the map. That is, the new displacement in x will be equal to the distance from the
	 * leftmost tile to the left edge plus the distance from the selected tile to the leftmost
	 * tile, and the same for the top in the y-dimension.
	 * 
	 * @param caller
	 * @param x
	 * @param y
	 */
	public void centerAbout(MapPanel caller, int x, int y) {
		// the new displacement should place (x, y) at the middle of the panel
		log.add("Centering about (" + x + ", " + y + ")");
		IntVector2D middle = new IntVector2D(caller.getWidth() / 2, caller.getHeight() / 2);
		IntVector2D orig = tileToCanvas(x - 1, y - 1).scalarSum(getScaledImgSize());
		setMapViewDisp(disp.sub(middle.sub(orig).scalarDiv(mapScale)));
		caller.repaint();
	}
	
	public void centerAbout(MapPanel caller, IntVector2D pos) {
		centerAbout(caller, pos.getX(), pos.getY());
	}
	
	public void centerScreen(MapPanel caller) {
		log.add("Centering screen");
		centerAbout(caller, caller.getXTiles() / 2, caller.getYTiles() / 2);
	}
	
	public void pan(MapPanel caller, IntVector2D diff) {
		setMapViewDisp(getMapViewDisp().sub(diff.scalarDiv(getMapScale())));
		fixOutOfBounds(caller);
		caller.repaint();
	}
	
	/**
	 * If the camera would be showing something too far away from the map, restores the map
	 * to the nearest "safe" state. 
	 * 
	 * @param caller
	 */
	public void fixOutOfBounds(MapPanel caller) {
		int wide = caller.getWidth();
		int high = caller.getHeight();
		int left = -2 * wide;
		int right = 3 * wide;
		int lower = -2 * high;
		int upper = 3 * high;
		IntVector2D stc = stateToCanvas(right, upper);
		if(left - disp.getX() > 0)
			disp.setX(left);
		else if(stc.getX() < caller.getWidth())
			disp.setX(right - (int) Math.floor(caller.getWidth() / mapScale));
		if(lower - disp.getY() > 0)
			disp.setY(lower);
		else if(stc.getY() < caller.getHeight())
			disp.setY(upper - (int) Math.floor(caller.getHeight() / mapScale));
	}
	
	/**
	 * Takes a coordinate pair of pixels and converts it to a coordinate pair
	 * on the game map.
	 * 
	 * @deprecated in favor of canvasToTile
	 * @param x The x-coordinate, in pixels.
	 * @param y The y-coordinate, in pixels.
	 * @return A vector representing the position on the game state.
	 */
	public IntVector2D canvasToState(double x, double y) {
		return canvasToState((int) x, (int) y);
	}
	
	/**
	 * Takes a coordinate pair of pixels and converts it to a coordinate pair
	 * on the game map.
	 * 
	 * @deprecated in favor of canvasToTile
	 * @param x The x-coordinate, in pixels.
	 * @param y The y-coordinate, in pixels.
	 * @return A vector representing the position on the game state.
	 */
	public IntVector2D canvasToState(int x, int y) {
		return new IntVector2D((int) (x / mapScale) + disp.getX(),
							   (int) (y / mapScale) + disp.getY());
	}
	
	/**
	 * Takes a coordinate pair on the game map and converts it to a coordinate
	 * pair of pixels.
	 * 
	 * @deprecated in favor of tileToCanvas
	 * @param x The x-coordinate, in terms of game tiles or something.
	 * @param y The y-coordinate, in terms of game tiles or something.
	 * @return A vector representing the position on the JPanel.
	 */
	public IntVector2D stateToCanvas(double x, double y) {
		return stateToCanvas((int) x, (int) y);
	}
	
	/**
	 * Takes a coordinate pair on the game map and converts it to a coordinate
	 * pair of pixels.
	 * 
	 * @deprecated in favor of tileToCanvas
	 * @param x The x-coordinate, in terms of game tiles.
	 * @param y The y-coordinate, in terms of game tiles.
	 * @return A vector representing the position on the JPanel.
	 */
	public IntVector2D stateToCanvas(int x, int y) {
		return new IntVector2D((int) ((x - disp.getX()) * mapScale),
							   (int) ((y - disp.getY()) * mapScale));
	}
	
	public int adjustmentToCenterOnTile() {
		return (int) (MapEntity.getCoordDisp() / 2 * mapScale);
	}
	
	private final static ImageIcon YELLOW_BOX = new ImageIcon("res/control/map/selector_yellow.gif");
	private final static ImageIcon RED_BOX = new ImageIcon("res/control/map/selector_red.gif");
	
	private class Selector extends Animation {

		public Selector() {
			super(16);
		}
		
		@Override
		public void paint(MapPanel caller, Graphics g) {
			ImageIcon currentIcon = isExamining() ? RED_BOX : YELLOW_BOX;
			if(!isHidden() && getFrameNumber() % getDelay() < getDelay() / 2) {
				if(selected == null)
					changeSelectedToCenter(caller);
				IntVector2D location = tileToCanvas(selected.getX(), selected.getY());
				currentIcon = getScaledImage(currentIcon,
						(int) (currentIcon.getIconWidth() * mapScale),
						(int) (currentIcon.getIconHeight() * mapScale));
				int adjust = (int) (MapEntity.getCoordDisp() / 2 * mapScale);
				currentIcon.paintIcon(caller, g, location.getX() - adjust,
						location.getY() - adjust);
			}
			super.paint(caller);
		}
	}

	@Override
	public void onUp(MapPanel caller) {
		changeSelected(caller, DS_Action.UP);
	}

	@Override
	public void onDown(MapPanel caller) {
		changeSelected(caller, DS_Action.DOWN);		
	}

	@Override
	public void onLeft(MapPanel caller) {
		changeSelected(caller, DS_Action.LEFT);
	}

	@Override
	public void onRight(MapPanel caller) {
		changeSelected(caller, DS_Action.RIGHT);
	}

	@Override
	public void onCancel(MapPanel caller) {
		if(caller.getGameStatus() == GameState.PLAYER_CONFIRMING_ATTACK
				|| caller.getGameStatus() == GameState.PLAYER_CONFIRMING_MOVE) {
			caller.getMapViewListener().disposeMoveMenu(MoveMenu.CANCEL);
		}
		if(caller.getGameStatus() != GameState.PLAYER_CONFIRMING_ATTACK) {
			if(caller.getGameStatus() == GameState.PLAYER_CONFIRMING_MOVE);
			else if(isExamining())
				unexamine(caller);
			else
				deselect(caller);
		}
	}

	@Override
	public void onConfirm(MapPanel caller) {
		GameState state = caller.getGameStatus();
		boolean promptingMove = state == GameState.PLAYER_CONFIRMING_MOVE;
		if(state == GameState.PLAYER_CONFIRMING_ATTACK) {
			if(caller.getMapConfig().attemptMove(caller)) {
				log.log("Made and initiated a valid attack");
				unexamine(caller);
			}
			else {
				log.log("Attempted invalid attack, game status not changing");
				changeSelected(caller, caller.getMapConfig().getEndOfPath());
			}
		}
		else if(!isSelecting() && !promptingMove)
			select(caller);
		else if(!isExamining() && !promptingMove)
			examine(caller);
		else if(isMoving() && !promptingMove) {
			if(!caller.getMapConfig().initiateMovePrompt(caller))
				unexamine(caller);
		}
		else
			return;
	}

	@Override
	public void onSelect(MapPanel caller) {
		toggleDangerZone(caller.getMapConfig());
	}

	private boolean dangerZoneOn;
	public boolean isDangerZoneOn() {
		return dangerZoneOn;
	}
	private void toggleDangerZone(MapConfiguration config) {
		dangerZoneOn = !dangerZoneOn;
		config.clearNonRedEnemySquares();
	}

	@Override
	public void onStart(MapPanel caller) { }

	@Override
	public void onLTrigger(MapPanel caller) { }

	@Override
	public void onRTrigger(MapPanel caller) { }
	
	/**
	 * Gets the size of all scaled images in this viewState instance..
	 * 
	 * @return MapEntity.SIZE * getMapScale(), which may not be an accurate representation of the
	 * scaled size if the size of the icons is not the same as specified by MapEntity.SIZE.
	 */
	public int getScaledImgSize() {
		return (int) (MapEntity.SIZE * getMapScale());
	}
	
	/**
	 * Scales the image sprite as appropriate.
	 * Taken mostly from http://stackoverflow.com/questions/6714045/how-to-resize-jlabel-imageicon
	 * 
	 * @param srcImg The original image.
	 * @param w The new width.
	 * @param h The new height.
	 * @return A new ImageIcon with the specified dimensions.
	 */
	public static ImageIcon getScaledImage(ImageIcon srcImg, int w, int h) {
		Image image = srcImg.getImage(); // transform it 
		Image newimg = image.getScaledInstance(w, h, java.awt.Image.SCALE_SMOOTH); // scale it the smooth way  
		return new ImageIcon(newimg);  // transform it back
	}
	
	/**
	 * Scales an image according to the mapScale value of a given MapViewState instance.
	 * @param srcImg The source image.
	 * @param s The MapViewState whose scale to use.
	 * @return A new scaled ImageIcon.
	 */
	public static ImageIcon getScaledImage(ImageIcon srcImg, MapViewState s) {
		return getScaledImage(srcImg, (int) (srcImg.getIconWidth() * s.getMapScale()), (int) (srcImg.getIconHeight() * s.getMapScale()));
	}
	
	public static void initVisualBindings() {
		VISUAL_BINDINGS = new KeyBinding<VisualAction>("visual", VisualAction.PAN_DOWN);
	}

}
